\chapter{Emulation Systems}
\label{chap:emulation}

To analyze a system, we must effectively represent its behavior for some case, or set of cases, of interest.
This dissertation is concerned with the emulation of systems or the effective duplication of a system for the purpose of identifying flaws, particularly with respect to security.
In Chapter~\ref{chap:rehost}, we will consider the process of rehosting a system to a different domain, in the context of hardware and instruction set emulators, which often allow complex embedded and cyberphysical systems to be analyzed on consumer desktop computers, e.g. laptops, and will consider dynamic analysis, a form of simulation which involves instrumentation of the system under analysis.
Chapter~\ref{chap:integreat} and Chapter~\ref{chap:info} will discuss consider high-level emulators, copies of a system in a more abstract domain, and function extraction, strategies allowing researchers to dissect complex hardware, firmware, and software systems into testable subcomponents.
Both Chapter~\ref{chap:rehost} and Chapter~\ref{chap:rehost} consider the use of symbolic execution and abstract interpretation as a mechanism for emulation, as these techniques explore multiple execution paths and thus implicitly emulate any single, particular execution trace as long as their lifting, semantics, and search strategies are able to identify it.
Every one of these discussed formalisms is well-known and each has several systems that implement the technique or strategy for a variety of real-world use cases~\cite{bellard2005qemu, quynh2015unicorn, deng2013bistro, caballero2009binary, sen2013jalangi, zaddach2014avatar, wang2017angr, cadar2008klee}.
This dissertation may be the first to organize these approaches as forms of emulation---detailed literature reviews are included alongside Chapters~\ref{chap:rehost},\ \ref{chap:info}, and~\ref{chap:integreat}.

In this chapter, we will introduce four different forms of emulation used in the analysis of complex systems.
For each form, we will identify contemporary system that implement the approach, define its nature and limitations, and provide examples.

\section{Peripheral Emulators and Instruction Set Simulators}
\label{sec:hardemu}

Embedded systems have different requirements than general purpose computers, and typically interact with specialized peripheral devices, such as actuators, and often run on different architectures designed for low power or high reliability usage (though the choice of ISA may also be due to age, cost costraints, and similar root causes).
We next define the core elements of emulators designed to duplicate the operation of embedded systems on general purpose computers~\cite{armstrong2019isa}.

\paragraph{Microarchitectural Semantics}

Semantics, for example, implies the content of the 12,940 pages of the Architecture Reference Manual~\cite{arm2023ref}, which describes the behavior of the ARMv8-A ISA, and the representation of the processor's state.

Base semantics for a microarchitecture consists of the behavior and specification of \emph{instructions} which are capable of being executed, the \emph{state} these instructions can affect, and \emph{peripheral} interfaces, such as memory mapped I/O.
Instructions and state capture of the security model of the architecture, such as exception handling and memory model capabilities (e.g. read-only access).
Peripheral interfaces define the capacity for the microarchitecture to interact with its environment, though not the behavior of the peripherals themselves (discussed in Sec.~\ref{sec:periphs}).
The entire semantics of the microarchitecture is typically captured in a \emph{specification language} for establishing the relationships between components.

Complex microarchitectural semantics may also be established through \emph{microprogramming}.
Microprogramming is a technique for implementing the behavior of an instruction by executing a sequence of simpler instructions.
The execution of several microcode instructions effectively emulates the behavior of a single instruction.
As a result of microprogramming and similar complex semantics, modeling the behavior of a processor is a highly complex task and provides continuous challenge to development of effective simulations for embedded systems.

\paragraph{Instruction Set Simulation}

An instruction set simulator (ISS) simulates the execution of instructions for a given ISA, typically by maintaining the state of the processor in its memory.

There are two primary approaches to implementing an ISS.
The first is to implement the behavior of each instruction in the ISA in a programming language, such as C, and to execute the instructions in the simulator by calling the appropriate function, maintaining the processor state in variables.
The second is to translate the effective behavior of the instructions into equivalent instructions on the host system, and to execute the translated instructions.
The first approach is easier to implement but the second approach is typically faster, as it avoids the overhead of function calls and the need to maintain the processor state in variables.
Modern architectures also increasingly support \emph{virtual machine} (VM) extensions, which allow the host system to adopt the second approach while maintaining security.

For many architectures there exist semantics that do not exist outside of reference documentation and the processor itself.
For these elements, the simulator must either ignore these semantics or emulate them through translation helper routines.
These helper routines and the translation rules for the simulator form an intermediate representation of the target's microarchtectural semantics.
The simulator may then be reused and leveraged to emulate a number of systems that are based on the represented ISA without necessitating ownership of a chip implementing the ISA.

\paragraph{An Example: QEMU}

QEMU is a general purpose emulator that supports a wide variety of ISAs and hardware peripherals~\cite{bellard2005qemu}.
QEMU is both a full system emulator, meaning that it is capable of emulating the behavior of an entire system, including peripherals, and capable of emulating the behavior of a processor in a virtual machine, which allows it to leverage the virtual machine extensions of the host system to accelerate the emulation of the target processor.
In cases where native execution is not possible, QEMU will emulate the instruction by executing a sequence of Tiny Code Generator (TCG) instructions operating over a C struct that stores the target architecture's microarchitectural state.
For example, the following PowerPC instruction:

% make listings pretty
\lstset{basicstyle=\ttfamily, keywordstyle=\color{blue}\ttfamily, stringstyle=\color{red}\ttfamily, commentstyle=\color{green}\ttfamily, morecomment=[l][\color{magenta}]{\#}}


\begin{center}
\begin{lstlisting}[]
0xfff0010c:  stw    r0,4(r1)
\end{lstlisting}
\end{center}

\noindent
translates into the following TCG instructions (where qemu\_st\_i32 refers to the \emph{guest} memory):

\begin{center}
\input{tcg-examp}
\end{center}

TCG instructions are a RISC-like instruction set that is designed to be easy to translate to the host system's ISA, and serve as an intermediate representation for the emulated system's machine code~\cite{tcg}.
Due to the complexity of certain microarchitectural semantics, QEMU also contains hundreds of TCG helper methods, which operate over the same C structure for the target architecture using C code.
These helper functions are triggered by failures in the translation process, and because not all of them are supported or correct, QEMU serves to emulate targets rather than reproduce them.

Note that the emulation process itself is composed of a larger execution loop, which is responsible for fetching instructions, translating them to TCG instructions, executing them, and modeling the behavior of hardware peripherals and interactions between multiple processors with respect to a given ISA's interfaces.

\paragraph{Hardware Peripherals}
\label{sec:periphs}

A \emph{peripheral} emulator models the behavior of hardware peripherals in order to better emulate the behavior of the overall system.
As a result, hardware peripherals must be represented either by connecting the emulator to the actual hardware, or by reproducing the peripheral in software.
As the space of potential peripherals is theoretically infinite, it becomes more essential to explicate the interfaces by which information is passed from hardware to the emulator.

Hardware peripherals are typically connected to the processor through a \emph{bus}, which is a shared communication channel that allows the processor to communicate with the peripheral.
Interfaces to a given bus are varied and dependent on the specific microarchitecture, as bus is a catch-all term covering hardware, software, and involved protocols.
For example, a processor may communicate with a peripheral through a memory-mapped I/O interface, which allows the peripheral to be accessed through the processor's memory interface, or a peripheral may communicate to the processor via an interrupt controller, which signals an exception to the processor.

A peripheral emulator must emulate the behavior of the peripheral and the behavioral portions of the processor's interface to the bus not covered by the ISS.
This is non-trivial as it can require deducing specific information about the peripheral layout and memory model of the embedded system under analysis, such as the I/O addresses of a given peripheral.
This information is not necessarily available for proprietary embedded systems and in these cases must be inferred from firmware code or other sources.\footnote{For example, Systems-on-Chip (SoCs) may be programmed with specific fuse values and flashed with read-only memory to indicate information about the peripheral model and some modern operating systems use specification files, e.g. device tree blobs, to indicate the layout of memory.}

\paragraph{Instrumentation}

For the purposes of this thesis, we are interested in \emph{instrumentation} of the ISS and peripheral emulator to collect information about the execution of the target system (Tab.~\ref{tab:instruments}).
The amount of instrumentation possible is dependent upon both the technique used to analyze the system and the completeness of the emulation.

Because these emulators have complete insight into the behavior of hardware, it is generally possible to \emph{actively} instrument them in order to collect information about execution.
Each instruction translation can be modified to collect information about various flows of execution, such as transfers of control or data.
It is also possible to inject artificial instructions and data into the emulated system, in order to explore the system's behaviors during certain peripheral interactions or when receiving particular inputs.
Extending this definition, it is also possible to execute the system from an entirely synthetic state in order to model specific behavioral traces.
If the simulator is sufficient, then it is also possible to use active instrumentation to secure otherwise insecure operations, such as by adding bounds checks to memory accesses or by adding checks to ensure that the system is not in an invalid state.

% table of active instrumentation techniques
\begin{table}[h]
\centering
\begin{tabular}{|l|l|}
\hline
\textbf{Technique} & \textbf{Description} \\ \hline
\multirow{2}{*}{Instruction Translation Modification} & \multirow{2}{*}{Modifies the translation of or injects instructions} \\
 & \\ \hline
\multirow{2}{*}{Data Injection} & \multirow{2}{*}{Introduces data into the system at some location} \\
 & \\ \hline
\multirow{2}{*}{Synthetic Execution} & \multirow{2}{*}{Executes the system from a synthetic state} \\
 & \\ \hline
\multirow{2}{*}{Secure Policy Enforcement} & \multirow{2}{*}{Adds security checks to the emulated system} \\
 & \\ \hline
\multirow{2}{*}{Monitoring Frameworks} & \multirow{2}{*}{Monitors the execution trace of the emulated system} \\
 & \\ \hline
\multirow{2}{*}{Interface as Subsystem} & \multirow{2}{*}{Incorporates the emulator into a larger system} \\
 & \\ \hline
\end{tabular}
\caption{Active and passive instrumentations in instruction set and peripheral emulators.}
\label{tab:instruments}
\end{table}

\emph{Passive} instrumentation is also possible, and active techniques are often combined with passive techniques to improve analysis.
This involves implementing monitoring frameworks which operate on the execution trace of the system and temporal reasoning operations for interpreting this trace.
These frameworks can provide performance benchmarking infromation but also significantly aid in the reverse engineering of the target system by indicating key information, such as explored paths in a symbol-stripped binary.
Passive instrumentation may also use the emulator as a black box and incorporating it into a larger system such as an enviromental simulator, to evaluate the dynamics of the larger system.

\section{Dynamic Analysis}


\subsection{Binary Rewriting}

\subsection{Fuzzing}

\subsection{Debuggers}

\section{Functional and High Level Emulators}

\subsection{Function Extraction and Summarization}

\subsection{Environmental Modeling}

\section{Symbolic Executors}

\subsection{Taint Tracking and Data Flow Analysis}
